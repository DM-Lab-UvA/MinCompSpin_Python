//#include <iostream>
#include <fstream>
#include <map>
#include <cmath>
#include <list>
#include <bitset> 
#include <set>
#include <vector>

using namespace std;

/********************************************************************/
/**************************    CONSTANTS    *************************/
/********************************************************************/
#include "data.h"

unsigned int k1_op(map<uint32_t, unsigned int> Nset, uint32_t Op)
{
  unsigned int k1 = 0;
  map<uint32_t, unsigned int>::iterator it;

  for (it = Nset.begin(); it != Nset.end(); it++)
  {
    k1 += (bitset<n>( ((*it).first) & Op ).count() % 2)*((*it).second); 
  }
  return k1;
}

/******************************************************************************/
/*********************************  Averages  *********************************/
/******************************************************************************/
// _all_Data_averages in ISING convention:
set<Operator> AllOp_m1_data_rank(map<uint32_t, unsigned int> Nset, unsigned int N)  
{
  Operator M;
  set<Operator> allOp; // Set of all the operators ordered by bias

  double Nd = (double) N;

  for (uint32_t Op = 1; Op <= NOp_tot; Op++)//NOp_tot
  {
    M.bin = Op;  M.layer = n;  // by default, all the Op belong to the last layer

    M.p1_M = 0.5;      // Noise Model: p1 = 0.5 for all operators
    M.p1_D = k1_op(Nset, Op)/Nd;
    
    M.S = (M.p1_D==0 || M.p1_D==1)? 0: -( (M.p1_D*log(M.p1_D) + (1.-M.p1_D)*log(1.-M.p1_D)) ); // Entropy of the data
    M.DKL = log(2.)-M.S;   // DK = max-log-likelihood for each Op, translated by (log2) and divided by N

    allOp.insert(M);
  }
  return allOp;
}

// _pairwise_Data_averages in ISING convention:
set<Operator> PairOp_m1_data_rank(map<uint32_t, unsigned int> Nset, unsigned int N)  
{
  Operator M;
  set<Operator> allOp; // Set of all the fields and pairwise operators ordered by bias

  double Nd = (double) N;

  uint32_t un_i = 1;
  uint32_t un_j = 1 << 1;

  for (int i=0; i<n; i++)
  { 
    // Field:
    M.bin = un_i;    M.layer = n;  // by default, all the Op belong to the last layer
    M.p1_M = 0.5;      // Noise Model: p1 = 0.5 for all operators
    M.p1_D = k1_op(Nset, M.bin)/Nd;
    M.S = (M.p1_D==0 || M.p1_D==1)? 0: -( (M.p1_D*log(M.p1_D) + (1.-M.p1_D)*log(1.-M.p1_D)) ); // Entropy of the data
    M.DKL = log(2.)-M.S;   // DK = max-log-likelihood for each Op, translated by (log2) and divided by N
    allOp.insert(M);

    // Pairwise:
    un_j = un_i << 1;
    for (int j=i+1; j<n; j++)
    {
      M.bin = un_i + un_j;
      M.p1_M = 0.5;    
      M.p1_D = k1_op(Nset, M.bin)/Nd;
      M.S = (M.p1_D==0 || M.p1_D==1)? 0: -( (M.p1_D*log(M.p1_D) + (1.-M.p1_D)*log(1.-M.p1_D)) ); // Entropy of the data
      M.DKL = log(2.)-M.S;   // DK = max-log-likelihood for each Op, translated by (log2) and divided by N
      allOp.insert(M);

      un_j = un_j << 1;
    }
    un_i = un_i << 1;
  }

  return allOp;
}

/******************************************************************************/
/*********************************  Best Basis  *******************************/
/******************************************************************************/
void add_new_basisOp(uint32_t new_basisOp, set<uint32_t> &OpSet, vector<unsigned int> &vect_op_used, int layer)
// new_basisOp = new basis operator to add
// OpSet = Set of all operators with the current basis
{
  set<uint32_t>::iterator it_Op;  // iterator on the set of already existing Operators: OpSet

  // buffer with the new operators:
  list<uint32_t> OpList_buffer;
  list<uint32_t>::iterator it_buffer;

  // Add basis Operator:
  OpList_buffer.push_back(new_basisOp);
  vect_op_used[new_basisOp] = layer;

  //Add created Operators:
  uint32_t created_Op = 0;
  for (it_Op = OpSet.begin(); it_Op != OpSet.end(); ++it_Op)
    {   
      created_Op = (*it_Op)^new_basisOp;
      OpList_buffer.push_back(created_Op);
      vect_op_used[created_Op] = layer;
    }

  // insert the operators from the buffer into the final operator set
  for (it_buffer = OpList_buffer.begin(); it_buffer != OpList_buffer.end(); ++it_buffer)
    { OpSet.insert(*it_buffer); }

  OpList_buffer.clear();
}

vector<pair<Operator, bool> > select_best_basis(set<Operator> &allOp_data, double Nd, double *LogL, int basis_size = n)
{
  set<Operator>::iterator it_Op;

// max-LogL best indep model:
  (*LogL) = 0;

// Basis operators:
  vector<pair<Operator, bool> > basis;

// Useful basis operators:
  int nb_basisOp_needed = 0;  bool STOP_basis = false;
  double dp_basis = sqrt(0.5*0.5/Nd);  // = sqrt(p1*(1.-p1)/Nd)  with p1 = 0.5

// Operators generated by the current basis:
  set<uint32_t> OpSet;

// Vector with layer information for operators already used (i.e. already affected to a layer):
  vector< unsigned int > vect_op_used(NOp_tot+1, basis_size);  // initialisation  //all operator not already used have "layer = n" (it's the last layer);

//********* All other basis operators:  phi_i:
  int counter = 0;
  it_Op = allOp_data.begin();
  unsigned int layer = 1;

  cout << "Best basis:" << endl;

  while( (it_Op != allOp_data.end()) && (basis.size() < basis_size) )
  {
    //search for the next basis operator:
    while(vect_op_used[(*it_Op).bin] < basis_size)
      {  it_Op++;  counter++;  (*it_Op).layer = vect_op_used[(*it_Op).bin]; } 

    //vect_op_used[(*it_Op).bin] = make_pair(true, layer);
    (*it_Op).layer = layer; //cout << layer << "\t " << bitset<n>((*it_Op).bin) << endl;
  
    // Useful basis operators?
    if( (abs( (*it_Op).p1_D - 0.5) > alpha * dp_basis) && STOP_basis == false) 
      {  
      nb_basisOp_needed++; 
      //(*it_Op).p1_M = (*it_Op).p1_D; 
      basis.push_back( make_pair(*it_Op, true) );   // New relevent basis operator
      }
    else 
      {  
      STOP_basis = true; 
      //(*it_Op).p1_M = (*it_Op).p1_D; // = 0.5 --> irrelevant basis Op
      basis.push_back( make_pair(*it_Op, false) );   // New unrelevent basis operator
      }

    // Implement the new basis operator:
    add_new_basisOp( (*it_Op).bin, OpSet, vect_op_used, layer );   // New operators generated by the basis
    layer++;

    // Output: 
    cout << "\t Op" << basis.size() << " = " << (*it_Op).bin << "\t= " << bitset<n>((*it_Op).bin);
    if (!STOP_basis) { cout << "\t ---> relevant: "; }
    else { cout << "\t ---> irrelevant: "; }
    cout << "  p = " << ((*it_Op).p1_D) << "\t DKL/N = " << (*it_Op).DKL << endl;
    (*LogL) += (-(*it_Op).S);

    //Remove the basis operator from the buffer:
    it_Op = allOp_data.erase(it_Op);    //cout << "Erase " << (*it_Op).bin << endl;
  }

  cout << endl << "Nb of accepted (\"relevant\") basis operators = " << nb_basisOp_needed << endl;
  cout << "Number of operators checked -- Counter = " << counter << endl;
  
  (*LogL) = Nd * (*LogL);
  cout << "Best Independent Model Max-LogL = " << (*LogL) << endl << endl; 

  if ( (it_Op == allOp_data.end()) && (basis.size() < n) )
    {  cout << "Error function \'select_best_model\': Pblem with the selection of the basis." << endl;  }

  return basis;
}

/******************************************************************************/
/*******************  PRINT BEST BASIS: FILE and TERM *************************/
/******************************************************************************/
void printfile_BestBasis(vector<pair<Operator, bool>> Op, double Nd, string name)  // print a list of Operators, with bit representation
{
  vector<pair<Operator, bool> >::iterator it_op; 
  int nb_basisOp_needed = 0;

  fstream fichier( (OUTPUT_directory + name + "BestBasis.dat").c_str(), ios::out);

// GENERAL INFORMATION:
  //terminal:
  double sig = 0.5/sqrt(Nd);  // var = sig^2 = (p*(1-p)/N)
  double p1 = 0.5 + alpha*sig;
  cout << "--->> For non-informative layers (i.e. non-relevant dimension), all operators have:" << endl;
  cout << "\t\t p1 = 0.5 +/- " << alpha*sig << " ( alpha*sig where alpha = " << alpha << " ) " << endl;
    p1 = 0.5 + sig; 
  cout << "\t\t Lmin = [" << -Nd*log(2.) << ", " << Nd*p1*log(p1) + Nd*(1.-p1)*log(1-p1);
    p1 = 0.5 + 3*sig; 
  cout << ", " << Nd*p1*log(p1) + Nd*(1.-p1)*log(1-p1);
    p1 = 0.5 + 4*sig; 
  cout << ", " << Nd*p1*log(p1) + Nd*(1.-p1)*log(1-p1) << "] = [ L(0.5), L(0.5+sig), L(0.5+3*sig), L(0.5+4*sig) ]"<< endl;
  cout << "\t99.73\% of the non-informative operators should end within the 3sigma interval." << endl << endl;

  //file:
  p1 = 0.5 + alpha*sig;
  fichier << "# --->> For non-informative layers (i.e. non-relevant dimension), all operators have:" << endl;
  fichier << "#\t\t p1 = 0.5 +/- " << alpha*sig << " ( alpha*sig where alpha = " << alpha << " ) " << endl;
    p1 = 0.5 + sig; 
  fichier << "#\t\t Lmin = [" << -Nd*log(2.) << ", " << Nd*p1*log(p1) + Nd*(1.-p1)*log(1-p1);
    p1 = 0.5 + 3*sig; 
  fichier << ", " << Nd*p1*log(p1) + Nd*(1.-p1)*log(1-p1);
    p1 = 0.5 + 4*sig; 
  fichier << ", " << Nd*p1*log(p1) + Nd*(1.-p1)*log(1-p1) << "] = [ L(0.5), L(0.5+sig), L(0.5+3*sig), L(0.5+4*sig) ]"<< endl;
  fichier << "#\t99.73\% of the non-informative operators should end within the 3sigma interval." << endl;
  fichier << "#" << endl;

// PRINT:
  fichier << "# 1:order(i) \t 2:p_i \t 3:LogL_i \t 4:maxLogL \t 5:BIC \t 6:MDL \t 7:Op \t 8:Op.bin" << endl << "#" << endl;

  int i = 0;
  double maxLogL = 0; //maxLogL = Nd*n*log(2.);
  for (it_op = Op.begin(); it_op != Op.end(); ++it_op)
  {  
    i++;
    //terminal:
//    cout << "\tDim " << count << ": \t phi^{" << (*it_op).first.bin << "}\t= " << bitset<n>((*it_op).first.bin);
//    if ((*it_op).second) { cout << "\t ---> relevant: "; nb_basisOp_needed++;  }
//    else { cout << "\t ---> irrelevant: "; }
//    cout << "  p = " << ((*it_op).first.p1);
//    cout << "\t LogL = " << ((*it_op).first.DKL) <<  endl;

    if ((*it_op).second) { nb_basisOp_needed++;  }
    //file:
    fichier << i << "\t";                   //order = i
    fichier << ((*it_op).first.p1_D) << "\t";  // p_i
    fichier << Nd*(-(*it_op).first.S) << "\t";   // maxLogL_i = N * [ p log p + (1-p) log (1-p) ]
    
    maxLogL += (-(*it_op).first.S);
    //maxLogL += Nd*(-(*it_op).first.S - log(2.) );
    fichier << Nd*(maxLogL - (n-i)*log(2.)) << "\t"; //maxLogL
    fichier << Nd*(maxLogL - (n-i)*log(2.)) - 0.5*i*log(Nd/(2.*M_PI)) << "\t"; //BIC
    fichier << Nd*(maxLogL - (n-i)*log(2.)) - 0.5*i*log(M_PI*Nd/2.) << "\t";  // MDL

    fichier << (*it_op).first.bin << "\t" << bitset<n>((*it_op).first.bin) << "\t" << bitset<n>((*it_op).first.bin).count() << endl; //operator
  } 
  fichier.close();

//  cout << endl << "'Relevant' means that the basis operator defines a relevant layer of operators:" << endl;
//  cout << "\t\t > Nb of relevant layers = " << nb_basisOp_needed  << "." << endl << endl;

//  cout << endl << "---> This " << Op.size() << " basis operators define a basis transformation from";
//  cout << " the basis of the n = " << n << " pure spin operators." << endl;
}
/*
list<__int128_t> Original_basis()
{
  list<__int128_t> Basis_li;
  __int128_t Op = 1;
  for (unsigned int i = 0; i < n; i++)
  {
    Basis_li.push_back(Op);
    Op <<= 1;
  }
  return Basis_li;
}*/
